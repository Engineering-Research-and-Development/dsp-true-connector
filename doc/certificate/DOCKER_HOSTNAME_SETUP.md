# Docker Hostname Setup - TLS Will Work! âœ…

## Your Question

**"If I run dockerized environment and use hostnames `connector-a` and `connector-b` in URL, will it work with certificates generated using only dedicated SANs?"**

## Answer: âœ… YES! It Works Perfectly!

The certificates generated by the script **already include** the hostnames you need:

```
connector-a certificate SANs:
  âœ… DNS:localhost
  âœ… DNS:connector-a  â† Perfect for Docker hostname!
  âœ… IP:127.0.0.1

connector-b certificate SANs:
  âœ… DNS:localhost
  âœ… DNS:connector-b  â† Perfect for Docker hostname!
  âœ… IP:127.0.0.1
```

## Docker Deployment - Works Out of the Box!

### Docker Compose Configuration

```yaml
version: '3.8'

services:
  connector-a:
    image: dsp-connector:latest
    container_name: connector-a
    hostname: connector-a         # Matches DNS:connector-a in certificate âœ…
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=consumer
    volumes:
      - ./connector-a.p12:/app/connector-a.p12:ro
      - ./dsp-truststore.p12:/app/dsp-truststore.p12:ro
    networks:
      - dsp-network

  connector-b:
    image: dsp-connector:latest
    container_name: connector-b
    hostname: connector-b         # Matches DNS:connector-b in certificate âœ…
    ports:
      - "8090:8090"
    environment:
      - SPRING_PROFILES_ACTIVE=provider
    volumes:
      - ./connector-b.p12:/app/connector-b.p12:ro
      - ./dsp-truststore.p12:/app/dsp-truststore.p12:ro
    networks:
      - dsp-network

networks:
  dsp-network:
    driver: bridge
```

### Application Configuration

**application-consumer.properties (in connector-a container):**
```properties
# Connect using Docker hostname - matches the SAN!
dsp.provider.url=https://connector-b:8090

# SSL configuration
spring.ssl.bundle.jks.connector.keystore.location=classpath:connector-a.p12
spring.ssl.bundle.jks.connector.truststore.location=classpath:dsp-truststore.p12
```

## How TLS Handshake Works in Docker

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Container: connector-a                                         â”‚
â”‚  Hostname: connector-a                                          â”‚
â”‚  Certificate: connector-a.p12                                   â”‚
â”‚  SANs: DNS:localhost, DNS:connector-a, IP:127.0.0.1            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â”‚ 1. Application makes request:
                     â”‚    https://connector-b:8090
                     â”‚    
                     â”‚ 2. Docker DNS resolves "connector-b"
                     â”‚    to connector-b container's IP
                     â”‚
                     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Container: connector-b                                         â”‚
â”‚  Hostname: connector-b                                          â”‚
â”‚  Certificate: connector-b.p12                                   â”‚
â”‚  SANs: DNS:localhost, DNS:connector-b, IP:127.0.0.1            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â”‚ 3. connector-b sends its certificate
                     â”‚
                     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  VALIDATION IN connector-a                                      â”‚
â”‚                                                                 â”‚
â”‚  âœ… Step 1: Trust Validation                                   â”‚
â”‚     â€¢ connector-b cert signed by: Intermediate CA              â”‚
â”‚     â€¢ connector-a truststore has: Intermediate CA              â”‚
â”‚     â€¢ Result: TRUST VALIDATED âœ…                               â”‚
â”‚                                                                 â”‚
â”‚  âœ… Step 2: Hostname Verification                              â”‚
â”‚     â€¢ URL hostname: "connector-b"                              â”‚
â”‚     â€¢ connector-b SANs: DNS:localhost, DNS:connector-b, ...    â”‚
â”‚     â€¢ Match found: DNS:connector-b âœ…                          â”‚
â”‚     â€¢ Result: HOSTNAME VERIFIED âœ…                             â”‚
â”‚                                                                 â”‚
â”‚  ğŸ‰ TLS HANDSHAKE SUCCESS!                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Why It Works

### 1. Docker DNS Resolution
Docker's internal DNS automatically resolves service/container names:
```
connector-b â†’ 172.18.0.3 (example Docker network IP)
```

### 2. Certificate Includes Hostname
The connector-b certificate includes the exact hostname:
```
SANs: DNS:localhost, DNS:connector-b, IP:127.0.0.1
                     ^^^^^^^^^^^^^^
                     This matches!
```

### 3. Hostname Verification Passes
When connector-a connects to `https://connector-b:8090`:
- Hostname in URL: **"connector-b"**
- SAN in certificate: **DNS:connector-b**
- Result: âœ… **MATCH!**

## Complete Docker Example

### 1. Generate Certificates

```cmd
cd connector\src\main\resources
generate-certificates.cmd
```

This generates:
- `connector-a.p12` with SAN `DNS:connector-a`
- `connector-b.p12` with SAN `DNS:connector-b`
- `dsp-truststore.p12` with Intermediate CA

### 2. Create docker-compose.yml

```yaml
version: '3.8'

services:
  connector-a:
    image: dsp-connector:latest
    container_name: connector-a
    hostname: connector-a
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=consumer
      - DSP_PROVIDER_URL=https://connector-b:8090
    volumes:
      - ./connector/src/main/resources/connector-a.p12:/app/connector-a.p12:ro
      - ./connector/src/main/resources/dsp-truststore.p12:/app/dsp-truststore.p12:ro
    networks:
      - dsp-network

  connector-b:
    image: dsp-connector:latest
    container_name: connector-b
    hostname: connector-b
    ports:
      - "8090:8090"
    environment:
      - SPRING_PROFILES_ACTIVE=provider
    volumes:
      - ./connector/src/main/resources/connector-b.p12:/app/connector-b.p12:ro
      - ./connector/src/main/resources/dsp-truststore.p12:/app/dsp-truststore.p12:ro
    networks:
      - dsp-network

networks:
  dsp-network:
    driver: bridge
```

### 3. Start Containers

```cmd
docker-compose up -d
```

### 4. Verify TLS Connection

```cmd
# Check from host machine
curl -v https://localhost:8090/actuator/health

# Check from connector-a container
docker exec connector-a curl -v https://connector-b:8090/actuator/health

# Should see:
# * SSL connection using TLSv1.3
# * Server certificate: CN=connector-b
# * SSL certificate verify ok
```

### 5. Check Logs

```cmd
docker logs connector-a
docker logs connector-b

# Should NOT see:
# âŒ PKIX path building failed
# âŒ No subject alternative names matching
```

## Comparison: What Works and What Doesn't

### âœ… WORKS - Using Dedicated Hostnames

**Docker Compose:**
```yaml
connector-a:
  hostname: connector-a    # Matches DNS:connector-a
connector-b:
  hostname: connector-b    # Matches DNS:connector-b
```

**Application Config:**
```properties
dsp.provider.url=https://connector-b:8090  # Matches DNS:connector-b âœ…
```

**Result:** âœ… **TLS handshake succeeds!**

### âŒ DOESN'T WORK - Using Different Names

**Docker Compose:**
```yaml
connector-a:
  hostname: consumer    # Does NOT match DNS:connector-a
connector-b:
  hostname: provider    # Does NOT match DNS:connector-b
```

**Application Config:**
```properties
dsp.provider.url=https://provider:8090  # Does NOT match DNS:connector-b âŒ
```

**Result:** âŒ **Hostname verification fails!**

**Error:**
```
java.security.cert.CertificateException: 
  No subject alternative names matching DNS name provider
```

**Fix Option 1 - Use Matching Hostnames (RECOMMENDED):**
Keep hostnames as `connector-a` and `connector-b` to match SANs

**Fix Option 2 - Update SANs:**
```batch
# In generate-certificates.cmd
set SAN_CONNECTOR_A=DNS:localhost,DNS:connector-a,DNS:consumer,IP:127.0.0.1
set SAN_CONNECTOR_B=DNS:localhost,DNS:connector-b,DNS:provider,IP:127.0.0.1
```

## Key Takeaways

### âœ… What You Need to Know

1. **Current SANs Already Include Docker Hostnames**
   - connector-a certificate: `DNS:connector-a` âœ…
   - connector-b certificate: `DNS:connector-b` âœ…

2. **No Changes Needed for Docker**
   - Use `hostname: connector-a` and `hostname: connector-b` in docker-compose
   - Use `https://connector-b:8090` in application config
   - TLS handshake works immediately!

3. **Docker DNS Handles Resolution**
   - `connector-b` â†’ Container IP (automatic)
   - TLS uses hostname for verification
   - Hostname matches SAN in certificate âœ…

4. **Same Truststore in Both Containers**
   - Both have `dsp-truststore.p12` with Intermediate CA
   - Trust validation succeeds for both directions

### ğŸ¯ Bottom Line

**You asked:** "Will it work in Docker with hostnames connector-a and connector-b?"

**Answer:** **YES! âœ…** The dedicated SANs (`DNS:connector-a` and `DNS:connector-b`) are **specifically designed** to make this work. No additional configuration or SAN changes needed!

## Testing Checklist

- [ ] Generate certificates with `generate-certificates.cmd`
- [ ] Verify connector-a.p12 has SAN `DNS:connector-a`
- [ ] Verify connector-b.p12 has SAN `DNS:connector-b`
- [ ] Create docker-compose.yml with hostnames matching SANs
- [ ] Start containers: `docker-compose up -d`
- [ ] Check connector-b is accessible: `curl https://localhost:8090/actuator/health`
- [ ] Check from connector-a: `docker exec connector-a curl https://connector-b:8090/actuator/health`
- [ ] Verify no PKIX or hostname verification errors in logs
- [ ] Test negotiation between connectors

## Related Documentation

- [CONNECTOR_TLS_COMMUNICATION.md](CONNECTOR_TLS_COMMUNICATION.md) - Complete TLS communication guide
- [CERTIFICATES_README.md](CERTIFICATES_README.md) - Certificate setup and configuration
- [generate-certificates.cmd](generate-certificates.cmd) - Certificate generation script

---

**Last Updated:** November 20, 2025  
**Script Version:** With dedicated SANs (SAN_CONNECTOR_A, SAN_CONNECTOR_B)  
**Status:** âœ… Docker hostname setup works out of the box!

